package com.data.a1_common

/**
  *
  * 设计：
  *     1. 尽量让方法没有副作用，返回值是唯一目的
  *         这样可以降低方法之间的耦合度，更加可靠，易于重用 (26)
  *
  *     2. 尽量不在函数中明确写出返回值，将每个方法当做是创建返回值的表达式
  *         鼓励程序员，将较大的方法分解为多个更小的方法
  *
  *     3. 函数式风格和指令式风格：包含了var的，很可能就是 指令式风格
  *          函数是否有副作用：可以通过返回类型是否为Unit来判断
  *
  * 说明：
  *     1. 方法的形参，默认都是val的，不能够重新赋值
  *     2. 方法与函数：如果去掉了=, 那么就是Unit返回值，必然是为了产生副作用，调用时必须带()？
  */
object a3_function extends App {

    /**
      * 如果是递归函数，那么函数返回值必须指定
      */

    /**
      * P 114 拥有第一类函数
      *     函数还可以写成没有名字的文本，函数文本和函数值类似于，类和对象的关系
      *         函数文本（存在于源代码中）被编译进一个类，运行期成为函数值
      */
    def operator_func()= {
        /**
          * 函数值是对象，因此可以存入对象
          *     任何函数都是扩展了 FunctionN 特性之一的实例，因此函数值可转换为 function value P114
          */
        val h = (x: Int) => x + 1

        /**
          * 简化函数
          *     1. 目标类型化：通过表达式的目标使用，决定了参数的类型，此时可以省略形参类型 P116
          *             同时可以省略被推断类型之外的括号
          *
          *     2. 占位符语法：每个参数在函数文本中仅出现一次
          *
          *     2. 函数只有一行，并且只有一个参数，可以省指代参数
          */
        val someNumbers = List(-11, -10, -5, 0, 5, 10)
        someNumbers.filter(x => x > 0)

        /**
          *             val f = _ + _
          *  占位符语法
          *         这里是错误的，编译器没有足够的类型来推断
          *         一个可行的方式是，在函数执行体中，指出参数类型，而不是在形参部分
          **/
        val f = (_: Int) + (_: Int)

        //    arg.foreach(println)
    }

    /**
      * * 无法直接操作方法，如果要操作方法，必须先将其转换成函数。有两种方法可以将方法转换成函数：
      * *
      * * val f1 = m _
      * * 支持闭包
      */

    operator_func
}
